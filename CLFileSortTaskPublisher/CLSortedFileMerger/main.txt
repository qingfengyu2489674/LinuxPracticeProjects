#include <iostream>
#include <filesystem>
#include <vector>
#include <fstream>
#include <stdexcept>
#include <thread>
#include <mutex>
#include "CLSortedFileMerger.h"

// 互斥锁保护文件表的增删操作
std::mutex file_table_mutex;
std::vector<std::string> file_table;  // 存储待归并的文件路径

// 打印合并后的文件内容
void print_merged_file(const std::string& output_file) {
    std::ifstream infile(output_file, std::ios::binary);
    if (!infile) {
        std::cerr << "Error opening output file: " << output_file << std::endl;
        return;
    }

    // 读取并打印文件中的所有 int64_t 数值
    int64_t value;
    while (infile.read(reinterpret_cast<char*>(&value), sizeof(value))) {
        std::cout << value << std::endl;
    }

    if (infile.eof()) {
        std::cout << "File read complete." << std::endl;
    } else {
        std::cerr << "Error reading file." << std::endl;
    }
}

void merge_task(std::vector<std::string>& file_table, const std::string& output_folder) {
    while (true) {
        std::vector<std::string> files_to_merge;

        // 使用互斥锁保护文件表的访问
        {
            std::lock_guard<std::mutex> lock(file_table_mutex);
            if (file_table.size() < 2) {
                return; // 不足两个文件可供合并，退出线程
            }

            // 取出两个文件进行归并
            files_to_merge.push_back(file_table.back());
            file_table.pop_back();
            files_to_merge.push_back(file_table.back());
            file_table.pop_back();
        }

        // 使用 SortedFileMerger 进行文件归并
        std::string merged_file = output_folder + "/merged_" + std::to_string(std::rand()) + ".bin";

        // 创建 CLSortedFileMerger 对象，传入段大小
        CLSortedFileMerger merger;

        // 将文件路径转换为 ifstream
        std::vector<std::ifstream> input_files;
        for (const auto& file : files_to_merge) {
            input_files.push_back(std::ifstream(file, std::ios::binary));
            if (!input_files.back()) {
                std::cerr << "Error opening file: " << file << std::endl;
                return;
            }
        }

        // 使用 CLMergeFiles 执行文件合并
        std::ofstream output_file(merged_file, std::ios::binary);
        if (!output_file) {
            std::cerr << "Error opening output file: " << merged_file << std::endl;
            return;
        }
        merger.CLMergeFiles(input_files, output_file);

        // 将归并后的文件添加到文件表中
        {
            std::lock_guard<std::mutex> lock(file_table_mutex);
            file_table.push_back(merged_file);
        }

        std::cout << "Merge complete: " << merged_file << std::endl;
    }
}

int main() {
    try {
        // 定义文件夹和输出文件名
        std::string folder = "../../sorted_files";  // 假设输入文件在此文件夹
        std::string output_folder = "./merged_output";  // 假设输出文件夹为此

        // 检查目录并列出文件
        if (!std::filesystem::exists(folder)) {
            throw std::runtime_error("Folder does not exist: " + folder);
        }

        // 检查输出目录是否存在，若不存在则创建
        if (!std::filesystem::exists(output_folder)) {
            std::filesystem::create_directory(output_folder);
        }

        // 扫描文件夹并将所有文件路径添加到文件表
        for (const auto& entry : std::filesystem::directory_iterator(folder)) {
            if (entry.is_regular_file()) {
                file_table.push_back(entry.path().string());
            }
        }

        // 检查是否有足够的文件
        if (file_table.size() < 2) {
            throw std::runtime_error("Not enough files in folder to merge.");
        }

        // 创建线程池，进行文件归并
        const size_t thread_count = 2; // 可调整线程数
        std::vector<std::thread> threads;
        for (size_t i = 0; i < thread_count; ++i) {
            threads.emplace_back(merge_task, std::ref(file_table), output_folder);
        }

        // 等待所有线程完成任务
        for (auto& t : threads) {
            t.join();
        }

        std::cout << "All merges complete." << std::endl;

        // 打印合并后的文件（示例）
        for (const auto& merged_file : file_table) {
            print_merged_file(merged_file);
        }

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
